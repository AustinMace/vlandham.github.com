---
layout: default
title: data types
---

h2. Data Types

In "lesson 1":variables.html we saw a preview of data types when we created variables to store a string and a number. Here we will dive into other data types available to the Ruby programmer.

In the world, there are many different types of data. Temperatures, last names, your birthday - these are all different *types* of data, right? When programming, we deal with these different types, differently. This allows us to interact with different types of data in ways that make sense with that data.

h3. Why Data Types?

Now we already saw the @String@ data type - a word or sentence surrounded by @"@. You might think to yourself, "why not store everything as a string?". Technically a string could be something like @"123.4"@, and thus _represent_ a number. The problem is we usually want to interact with numbers as numbers. Add, subtract, log; these are all operations on numbers. These operations don't make sense, or don't mean the same thing, with strings. 

So in short, data types allow us to work with data in ways that makes sense with that data.

h3. Variables and Data Types

So what is the relationship between variables and data types? Well, remember, a variable _stores_ a particular piece of data, allowing you to use it later. So a variable represents a particular piece of data with a particular data type.

Open @irb@ and create some variables 

{% highlight ruby %}
person = "John Higgins"
result = 430
{% endhighlight %}

Just as a review, @person@ is a variable that *stores* (or *points at*) the string @"John Higgins"@. @result@ is a variable that stores the number @430@. Got it?

In Ruby, a variable can point to any kind of data type. Furthermore, you can change the data, and the data type that a variable points to. Try this:

{% highlight ruby %}
result = "success"
{% endhighlight %}

See what we just did? The variable @result@ now points to the *string* @"success"@. This is no big deal for Ruby, but for the programmer, you usually need to have some idea of what a variable is storing, so you know how to interact with that data.

Another quick question: what happened to the number @430@? Well, there is no other variable pointing to that number, so its gone, destroyed, lost. If you don't have a variable pointing to a piece of data, then you don't have that data.

h3. Methods

I've been talking about _interacting_ and _dealing_ with different types of data, but what does that really mean? Well, in Ruby each type of data responds to a different set of commands. These commands are know as *Methods* of that particular data type. You can think of methods as _commands_ or _questions_ you are sending the data type. We will talk a lot more about methods in the future - but in order to appreciate the differences between data types, its good to know a bit about how to interact with them.

To call a method on a data type, you type the data or the variable pointing to the data then you type period (@.@), and then the method name and then parenthesis (@()@). Its not as difficult as it sounds.

For example, strings have a method called @length@. When you call @length@ on a string, the string tells you how long it is. In @irb@ this is reported back immediately after you hit the return key. Lets try it:

{% highlight ruby %}
result = "a party"
result.length()
# => 7
{% endhighlight %}

The method @length@ returned @7@ for the string @"a party"@.

Just to show this is a method connected to the data type and not the variable, lets call the same method on a string that isn't pointed to by a variable:

{% highlight ruby %}
"a big mess".length()
# => 10
{% endhighlight %}

Also, lets try calling @length@ on a number - to show that this method can be called on strings, but not numbers:

{% highlight ruby %}
123.length()
# => NoMethodError: undefined method `length' for 123:Fixnum
# =>	from (irb):5
# =>	from /Users/jfv/.rvm/rubies/ruby-1.9.2-p180/bin/irb:16:in `<main>'
{% endhighlight %}

You see? The number @123@ doesn't know how to respond to the method @length@ and so raises an error. This is what I mean by interacting with different data types appropriately.

We will get back to methods later.

Now lets review some of the data types you have in Ruby. Hunker down and dig in!

h2. Integer

Ok, I've been referring to numbers as just numbers - but that is not entirely accurate. There are actually *two* different types of numbers: @Integers@ and @Floats@. Integers are *whole numbers*. @123@, @40001@, @12@ are all examples of Integers.

In the example above, when we called @123.length()@ - the error message we got indicated that 123 was something called a @Fixnum@. That is just what ruby usually calls an @Integer@. We will keep calling @Integers@ @Integers@, because that is what they are.

One thing to remember about Integers is that performing operations with Integers usually results in an Integer. The big thing to watch out here with is when performing division:

{% highlight ruby %}
10 / 4
# => 2
{% endhighlight %}

Huh? @10 / 4@ in the real world is @2.5@, right? However, with Integers, operations return Integers. @2.5@ is not an @Integer@, so the operation rounds down. Sometimes this is what we want. Other times, we need to use @Floats@.

h2. Float

A @Float@ is the other type of number in programming. A @Float@ stores any real number: @12.4@, @1245.5555@, @34.0@. You can see that you always use decimal notation when writing a float. Also, you don't separate numbers with a comma. 

See the @Float@ @34.0@? This is how we represent a whole number when we want to store it as a @Float@. The @.0@ tells Ruby to not store it as an @Integer@. Operations with @Floats@ return @Floats@:

{% highlight ruby %}
10.0 / 4.0
# => 2.5
{% endhighlight %}

Alright! Math makes sense again.

What about operations involving both @Floats@ and @Integers@?

{% highlight ruby %}
10 / 4.0
# => 2.5

10.0 / 4
# => 2.5

10 / 4 + 2.5
# => 4.5

10.0 / 4 + 2.5
# => 5.0
{% endhighlight %}

You see what is happening? Each operation is looked at separately (and in the order of the order of operations). If one of the values in the operation is a @Float@, then the return value is a @Float@. With @10 / 4 + 2.5@, the first operation executed (division of 10 by 4) only has @Integers@ in it - so its returned value is also an @Integer@ (@2@). But then this @2@ is added to @2.5@, which is a @Float@, so the end result is a @Float@. 

Play around with other operations with @Floats@ and @Integers@.

h2. String

We've seen @Strings@ a few times now. We know @Strings@ store characters, words, sentences, paragraphs, etc. Its all text. Strings store text. You indicate the data is a string by surrounding it with quotes (@"@).

{% highlight ruby %}
name = "Josh Meyer"
{% endhighlight %}

One very nice thing about @Strings@ in Ruby is that you can insert variables into them using some special syntax. Let's see an example:

{% highlight ruby %}
name = "Willy Shakes"
title = "Love Sucks"
count = 4

"#{name} wrote the play #{title} #{count} times before getting it right"
# => "Willy Shakes wrote the play Love Sucks 4 times before getting it right"
{% endhighlight %}

Breaking it down: we first create 3 variables, @name@, @title@, and @count@. Then we insert these variables into a string by using the syntax: @#{variable_name}@. So pound sign (@#@), open curly bracket (@{@), the variable name, then close curly bracket (@}@). It might look a little weird at first, but hopefully you can start thinking about how powerful this is!

h2. Array

h2. Hash

h2. Boolean

h2. Nil
