---
layout: post
title: Really Quick Git
categories:
- git
---

h3. An attempt to quickly demonstrate the usefulness of Git for the single-developer environment

h2. What does Git give you as an individual developer?

* History of changes you made to your files. 
** Allows you to see when particular changes / features were implemented.
** Also can provide an explanation to why you changed something the way you did.
* 'Universal undo'
** Revert changes to any file you are tracking in Git.
** Completely external to the particular editor you are using at the time.
** Useful when a rm goes bad, or when you get crazy with Vim (":d20j :wq").
* Test out new changes / ideas without fear.
** Branching capabilities in Git make it easy to try out large scale modifications to your code that you can always revert if things don't work out. 
** Also could be useful if you need to have a number of versions of your code with small tweaks in them.
* Tagging allows you to know exactly how your code looked at a particular revision
** Useful for when you need to know if a bug / feature was present in the code at version x

h2. What a central Git repository (like Github) gives you

* Easily share code in a consistent, familiar manner.
* Provide a backup of your source code for when your harddrive crashes.
* A quick place to share code with yourself on multiple computers.
** Keep working (and maintaining a history of your work) no matter where you are.

h2. Worth it?

I think it can be hard to prove that the added benefit you get from a version control system is worth the effort it takes to use it. Hopefully I can show that even with just a minimal amount of overhead, Git can be an valuable tool.

h2. Assumptions

* You are on a *nix based machine
* Git is already installed on your system

h2. Initial Setup

There are a few steps that are good to take care of up front, to avoid frustrations later on. We will just execute these commands without too much explanation as to the details of what they do. Commands are executed in the terminal.

h3. Set your get name and email

{% highlight bash %}
git config --global user.name "Jim Somebody"
git config --global user.email "jims@domain.com"
{% endhighlight %}

h3. Turn on color for your git output

{% highlight bash %}
git config --global color.ui true
{% endhighlight %}

h3. Add global gitignore file for temporary files

{% highlight bash %}
# create .gitignore in home directory
touch ~/.gitignore
# add some files patterns to ignore
echo "*.swp" >> ~/.gitignore
echo ".DS_Store" >> ~/.gitignore
# tell git about our global ignore
git config --global core.excludesfile ~/.gitignore
# you can add to this .gitignore file later
# and each git project also can have its own 
# specific .gitignore
{% endhighlight %}

Ok, that takes care of most of the setup stuff. Lets get to using Git.

h2. How Git works - the basics

Here's a quick rundown of the basic points on how Git operates.

h4. You Commit Changesets to a Git repository

Git works with groups of changes to your files, which we will call changesets. A changeset can include adding / removing text inside a file and / or adding / removing entire files. A changeset is commited to the git repository to track the changes. The idea here is that each changeset should optimally contain changes for a single logical modification to your code.

So, for example, if you codebase is a command line tool, a possible changeset would be adding the ability to specify an output directory. You would commit all the file modifications to complete this change as a single changeset. Another changeset could be the creation of a new class to represent 'xyz'. That would go into its own changeset and that changeset would be commited to the repository. 

You can work at a lower or higher scope than this, but I belive working with individual logical changes as individual changes allows you to get the most from your repository. 

h4. Git has a Staging area to Prepare your Commits

As changesets can and often do include multiple files, you need a way to group your changes before commiting. That's where the staging area comes in. The staging area is a holding place for changes in a changeset that will be commited. 

This makes commiting a change a 2 step process:
* First, a change is added to the staging area
* Then, the set of changes in the staging area (your changeset) is commited.

This makes it easy to have lots of modified files, but pick and choose which changes go into individual commits. Without a staging area, you would have to either only work on a single changeset at a time, or be forced to combine modifications from different logical modifications into one large commit. Both of these options are no good - hence the staging area. 
